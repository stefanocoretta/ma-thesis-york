The following is just the header of the script.

<<*>>=
######################################
# get_measurements.praat v0.1.0
######################################
# Copyright 2016 Stefano Coretta
#
# stefanocoretta.altervista.org
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.
######################################
# This script reads the TextGrid files in the specified folder and it extracts several measures from them.
######################################

@


Then the form to fill in.

<<*>>=
form Select folder with TextGrid files
    comment Directory of TextGrid files. Include final '/'
    text textgrid_directory /Users/Stefano/Documents/GitHub/icelandic-preaspiration/TextGrid/
    sentence textgrid_extension .TextGrid
    sentence result_file results.csv
endform

@

Now we can create a list of the TextGrid files and create the result file.
The extension \texttt{\textunderscore{}no} in variable names means \texttt{\textunderscore{}number}.
Then we check if the result file already exists and if it does, we prompt the user if she wants to overwrite it.

<<*>>=
Create Strings as file list: "list", "'textgrid_directory$'*'textgrid_extension$'"
files_no = Get number of strings

if fileReadable (result_file$)
	pause The file 'result_file$' already exists! Do you want to overwrite it?
	filedelete 'result_file$'
endif

@

We prepare the header of the result file and append it to it.
The result file is created in the same folder where the script is.

<<*>>=
header$ = "speaker,idx,word,beg_word,end_word,dur_word,beg_voic,end_voic,dur_voic,
...beg_mann,end_mann,dur_mann,rels,dur_vowel,dur_cc,dur_clos,vor,voffr,
...mor'newline$'"
fileappend "'result_file$'" 'header$'

@


Let's give the indexes of each tier.

<<*>>=
sent = 1
word = 2
voic = 3
mann = 4
rels = 5

@


First, we need to get the number of intervals from the second tier.

<<*>>=
for file to files_no
    file_name$ = Get string: file
    Read from file: "'textgrid_directory$''file_name$'"

    intervals_no = Get number of intervals: word
    under_index = index(file_name$, "_")
    speaker$ = left$(file_name$, under_index - 1)
@

Than we can loop through those and check which are non-empty.
The variable "int\textunderscore{}word" contains the index (numeric) of the current interval on the word tier.

<<*>>=
    index = 0
    for int_word to intervals_no
        lab_word$ = Get label of interval: word, int_word
        if lab_word$ <> ""
        index += 1
@

If they are non-empty get label, beginning and end, and calculate the duration.

<<*>>=
            begin_word = Get starting point: word, int_word
            end_word = Get end point: word, int_word
            dur_word = (end_word - begin_word) * 1000

@

Get index and label of interval on voic.

<<*>>=
            int_voic = Get interval at time: voic, begin_word
            label$ = Get label of interval: voic, int_voic
@


If the interval on voic it's non-empty, get begin and end, and calculate duration.

<<*>>=
            if label$ <> ""
                begin_voic = Get starting point: voic, int_voic
                end_voic = Get end point: voic, int_voic
                dur_voic = (end_voic - begin_voic) * 1000
@


Otherwise, get index of the next interval (int\textunderscore{}voic + 1) on voic tier.

<<*>>=
            else
                int_voic = int_voic + 1
@


If the first interval on voic is empty, then the next will always be non-empty.
We can just get begin and end, and calculate duration.
Terminate if.

<<*>>=
                begin_voic = Get starting point: voic, int_voic
                end_voic = Get end point: voic, int_voic
                dur_voic = (end_voic - begin_voic) * 1000
            endif

@

Get interval index and label on the mann tier at time = end - 0.00001 of the interval on the voic tier.

<<*>>=
            int_mann = Get interval at time: mann, end_voic - 0.00001
            label$ = Get label of interval: mann, int_mann
@

If the interval is non-empty, get begin and end, and calculate duration.
If it's empty, record nulls.

<<*>>=
            if  label$ <> ""
                begin_mann = Get starting point: mann, int_mann
                end_mann = Get end point: mann, int_mann
                dur_mann = (end_mann - begin_mann) * 1000

                begin_mann$ = string$(begin_mann)
                end_mann$ = string$(end_mann)
                dur_mann$ = string$(dur_mann)
            else
                begin_mann$ = ""
                end_mann$ = ""
                dur_mann$ = ""
            endif

@

Get nearest boundary on tier rels to the end of the word.
If the release is withing the words boundaries, calculate VOR, VOFFR and MOR and string$ them.
Otherwise, set them to NULL.

<<*>>=
            ind_rels = Get nearest index from time: rels, end_word
            time_rels = Get time of point: rels, ind_rels
            if time_rels > begin_word and time_rels < end_word
                if label$ <> ""
                    dur_clos = (time_rels - end_mann) * 1000
                    son_spread = (end_mann - end_voic) * 1000
                    son_spread$ = string$(son_spread)
                else
                    dur_clos = (time_rels - end_voic) * 1000
                    son_spread$ = ""
                endif
                vor = (time_rels - begin_voic) * 1000
                voffr = (time_rels - end_voic) * 1000
                mor = (time_rels - begin_mann) * 1000

                dur_clos$ = string$(dur_clos)
                vor$ = string$(vor)
                voffr$ = string$(voffr)
                mor$ = string$(mor)
            else
                dur_clos$ = ""
                vor$ = ""
                voffr$ = ""
                mor$ = ""
            endif
@

Calculate vowel duration (voice onset to manner onset)

<<*>>=
            if label$ <> ""
                dur_vowel = (begin_mann - begin_voic) * 1000
                dur_vowel$ = string$(dur_vowel)
            else
                dur_vowel = dur_voic
                dur_vowel$ = string$(dur_vowel)
            endif
@

Write output.
If the label on the mann tier is empty, then input empty data.
If the release time is not within the time boundaries of the word, input empty data.

<<*>>=
            result_line$ = "'speaker$','index','lab_word$','begin_word','end_word','dur_word','begin_voic','end_voic','dur_voic','begin_mann$','end_mann$','dur_mann$','time_rels','dur_vowel$',x,'dur_clos$','vor$','voffr$','mor$''newline$'"
            fileappend "'result_file$'" 'result_line$'
@

Terminate if (2 tabs), for (1 tab), select the list with files, and terminate for (0 tabs).

<<*>>=
        endif
    endfor
    selectObject: "Strings list"
endfor

@
