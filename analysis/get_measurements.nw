The following is just the header of the script.

<<*>>=
######################################
# get_measurements.praat v0.1.0
######################################
# Copyright 2016 Stefano Coretta
#
# stefanocoretta.altervista.org
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.
######################################
# This script reads the TextGrid files in the specified folder and it extracts several measures from them.
######################################

@


Then the form to fill in.

<<*>>=
form Select folder with TextGrid files
    comment Directory of TextGrid files. Include final '/'
    text textgrid_directory /Users/Stefano/Google Drive/Icelandic/audio/
    sentence textgrid_extension .TextGrid
    sentence result_file results.csv
endform

@

Now we can create a list of the TextGrid files and create the result file.
The extension \texttt{\textunderscore{}no} in variable names means \texttt{\textunderscore{}number}.
Then we check if the result file already exists and if it does, we prompt the user if she wants to overwrite it.

<<*>>=
Create Strings as file list: "list", "'textgrid_directory$'*'textgrid_extension$'"
files_no = Get number of strings

if fileReadable (result_file$)
	pause The file 'result_file$' already exists! Do you want to overwrite it?
	filedelete 'result_file$'
endif

@

We prepare the header of the result file and append it to it.
The result file is created in the same folder where the script is.

<<*>>=
header$ = "file_name,idx,word,beg_word,end_word,dur_word,beg_voic,end_voic,dur_voic,
...beg_mann,end_mann,dur_mann,rels,dur_v_to_m,dur_clos,abs_voic,abs_clos,norm_voic,
...norm_mann,norm_v_to_m,norm_clos,norm_abs_voic,norm_abs_clos,vor,voffr,
...spread,norm_spread,mor'newline$'"
fileappend "'result_file$'" 'header$'

@


Let's give the indexes of each tier.

<<*>>=
sent = 1
word = 2
voic = 3
mann = 4
rels = 5

@


First, we need to get the number of intervals from the second tier.

<<*>>=
for file to files_no
    file_name$ = Get string: file
    Read from file: "'textgrid_directory$''file_name$'"

    intervals_no = Get number of intervals: word

@

Than we can loop through those and check which are non-empty.
The variable "int\textunderscore{}word" contains the index (numeric) of the current interval on the word tier.

<<*>>=
    index = 0
    for int_word to intervals_no
        lab_word$ = Get label of interval: word, int_word
        if lab_word$ <> ""
        index += 1
@

If they are non-empty get label, beginning and end, and calculate the duration.

<<*>>=
            begin_word = Get starting point: word, int_word
            end_word = Get end point: word, int_word
            duration_word = (end_word - begin_word) * 1000

@

Get index and label of interval on voic.

<<*>>=
            int_voic = Get interval at time: voic, begin_word
            label$ = Get label of interval: voic, int_voic
@


If the interval on voic it's non-empty, get begin and end, and calculate duration.

<<*>>=
            if label$ <> ""
                begin_voic = Get starting point: voic, int_voic
                end_voic = Get end point: voic, int_voic
                duration_voic = (end_voic - begin_voic) * 1000
@


Otherwise, get index of the next interval (int\textunderscore{}voic + 1) on voic tier.

<<*>>=
            else
                int_voic = int_voic + 1
@


If the first interval on voic is empty, then the next will always be non-empty.
We can just get begin and end, and calculate duration.
Terminate if.

<<*>>=
                begin_voic = Get starting point: voic, int_voic
                end_voic = Get end point: voic, int_voic
                duration_voic = (end_voic - begin_voic) * 1000
            endif

@

Get interval index and label on the mann tier at time = end - 0.00001 of the interval on the voic tier.

<<*>>=
            int_mann = Get interval at time: mann, end_voic - 0.00001
            label$ = Get label of interval: mann, int_mann
@

If the interval is non-empty, get begin and end, and calculate duration.
#If it's empty, record nulls.

<<*>>=
            if  label$ <> ""
                begin_mann = Get starting point: mann, int_mann
                end_mann = Get end point: mann, int_mann
                duration_mann = (end_mann - begin_mann) * 1000
#            else
#                begin_mann$ = ""
#                end_mann$ = ""
#                duration_mann$ = ""
            endif

@

Get nearest boundary on tier rels to the end of the word.
Calculate the interval Vonset-to-release for normalisation.

<<*>>=
            ind_rels = Get nearest index from time: rels, end_word
            time_rels = Get time of point: rels, ind_rels
            v_to_rel = (time_rels - begin_voic) * 1000
            voff_to_rel = (time_rels - end_voic) * 1000
            mor = (time_rels - begin_mann) * 1000
            norm_mor = mor / v_to_rel
@

Calculate voice-onset to manner-onset and closure duration (manner-offset to release).
Need closure for non mann as well!
Calculate the duration of the spreading gesture.
In words with pre-aspirated consonants this is equal to \texttt{dur_mann}.
In words with sonorants it is the duration of the interval between the offset of voicing and the offset of manner.

<<*>>=
            if label$ <> ""
                duration_v_to_m = (begin_mann - begin_voic) * 1000
                duration_closure = (time_rels - end_mann) * 1000
                duration_abs_closure = (time_rels - begin_mann) * 1000
                if label$ <> "spr"
                    duration_spread = (end_mann - end_voic) * 1000
                    norm_duration_spread = duration_spread / v_to_rel
                else
                    duration_spread = duration_mann
                    norm_duration_spread = norm_duration_mann
                endif
                if duration_spread == 0
                    duration_spread$ = ""
                    norm_duration_spread$ = ""
                else
                    duration_spread$ = string$(duration_spread)
                    norm_duration_spread$ = string$(norm_duration_spread)
                endif

            else
                duration_closure = (time_rels - end_voic) * 1000
                duration_spread$ = ""
                norm_duration_spread$ = ""
            endif
@

Write output.
If the label on the mann tier is empty, then input empty data.
If the release time is not within the time boundaries of the word, input empty data.

<<*>>=
            if label$ <> ""
                norm_duration_voice = duration_voic / v_to_rel
                norm_duration_mann = duration_mann / v_to_rel
                norm_duration_v_to_m = duration_v_to_m / v_to_rel
                norm_abs_clos = duration_abs_closure / v_to_rel
                if time_rels > begin_word and time_rels < end_word
                    norm_duration_closure = duration_closure / v_to_rel
                    result_line$ = "'file_name$','index','lab_word$','begin_word','end_word','duration_word','begin_voic','end_voic','duration_voic','begin_mann','end_mann','duration_mann','time_rels','duration_v_to_m','duration_closure','duration_v_to_m','duration_abs_closure','norm_duration_voice','norm_duration_mann','norm_duration_v_to_m','norm_duration_closure','norm_duration_v_to_m','norm_abs_clos','v_to_rel','voff_to_rel','duration_spread$','norm_duration_spread$','mor''newline$'"
                    fileappend "'result_file$'" 'result_line$'
                else
                    result_line$ = "'file_name$','index','lab_word$','begin_word','end_word','duration_word','begin_voic','end_voic','duration_voic',,,,,,,,,'norm_duration_voice',,,,,,,,'duration_spread$','norm_duration_spread$','mor''newline$'"
                    fileappend "'result_file$'" 'result_line$'
                endif
            else
                norm_duration_voice = duration_voic / v_to_rel
                if time_rels > begin_word and time_rels < end_word
                    norm_duration_closure = duration_closure / duration_word
                    result_line$ = "'file_name$','index','lab_word$','begin_word','end_word','duration_word','begin_voic','end_voic','duration_voic',,,,'time_rels',,'duration_closure','duration_voic','duration_closure','norm_duration_voice',,,'norm_duration_closure','norm_duration_voice','norm_duration_closure','v_to_rel','voff_to_rel','duration_spread$','norm_duration_spread$','mor''newline$'"
                    fileappend "'result_file$'" 'result_line$'
                else
                    result_line$ = "'file_name$','index','lab_word$','begin_word','end_word','duration_word','begin_voic','end_voic','duration_voic',,,,,,,'duration_voic',,'norm_duration_voice',,,,'norm_duration_voice',,,,'duration_spread$','norm_duration_spread$','mor''newline$'"
                    fileappend "'result_file$'" 'result_line$'
                endif
            endif

@

Terminate if (2 tabs), for (1 tab), select the list with files, and terminate for (0 tabs).

<<*>>=
        endif
    endfor
    selectObject: "Strings list"
endfor

@
